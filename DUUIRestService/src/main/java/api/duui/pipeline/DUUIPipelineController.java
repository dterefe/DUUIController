package api.duui.pipeline;

import api.duui.component.DUUIComponentController;
//import api.duui.routines.service.DUUIService;
import api.duui.routines.process.DUUIProcess;
import api.duui.routines.service.DUUIService;
import api.http.DUUIRequestHandler;
import api.requests.validation.UserValidator;
import api.storage.AggregationProps;
import api.storage.DUUIMongoDBStorage;
import com.mongodb.client.AggregateIterable;
import com.mongodb.client.model.*;
import com.mongodb.client.result.DeleteResult;
import org.bson.Document;
import org.bson.conversions.Bson;
import org.bson.types.ObjectId;
import org.texttechnologylab.DockerUnifiedUIMAInterface.monitoring.DUUIStatus;
import spark.Request;
import spark.Response;

import java.time.Instant;
import java.util.*;
import java.util.stream.StreamSupport;

import static api.requests.validation.UserValidator.authenticate;
import static api.requests.validation.Validator.isNullOrEmpty;
import static api.requests.validation.Validator.missingField;
import static api.storage.DUUIMongoDBStorage.*;

public class DUUIPipelineController {
    private static final Map<String, DUUIService> keepAliveProcesses = new HashMap<>();

    private static final Set<String> ALLOWED_UPDATES = Set.of(
        "name",
        "description",
        "settings",
        "tags",
        "timesUsed",
        "lastUsed",
        "components"
    );

    private static final Set<String> SORTABLE_FIELDS = Set.of(
        "name",
        "description",
        "created_at",
        "modified_at",
        "status",
        "times_used"
    );

    public static Set<String> getAllowedUpdates() {
        return ALLOWED_UPDATES;
    }

    public static Set<String> getSortableFields() {
        return SORTABLE_FIELDS;
    }

    /**
     * Retrieve one pipeline given its id.
     *
     * @param id A unique 24 character identifier generated by MongoDB.
     * @return A document containing the pipeline data or null if nothing matched.
     */
    public static Document getPipelineById(String id) {
        Document result;

        try {
            result =
                DUUIMongoDBStorage
                    .Pipelines()
                    .find(Filters.eq(new ObjectId(id)))
                    .first();

        } catch (IllegalArgumentException exception) {
            result = null;
        }

        if (result == null) return null;

        List<Document> components = DUUIComponentController.getComponentsForPipeline(id);
        convertObjectIdToString(result);
        return result.append("components", components);
    }

    /**
     * Retrieve one or more pipelines from the database given a userID and {@link AggregationProps} to sort
     * and filter the results.
     *
     * @param userID        The userID to identify pipelines belonging to the account.
     * @param props         Props that determine sort, order, limit and skip values.
     * @param getComponents Wether to include components in the pipeline data.
     * @return A Document containing a list of matched pipelines.
     */
    public static Document getPipelinesByUserID(String userID, AggregationProps props, boolean getComponents) {
        List<Bson> aggreagtion = new ArrayList<>();

        aggreagtion.add(Aggregates.match(Filters.in("user_id", userID, null)));
        aggreagtion.add(Aggregates.addFields(new Field<>("oid", new Document("$toString", "$_id"))));
        aggreagtion.add(Aggregates.project(Projections.excludeId()));

        if (!props.getSort().isEmpty() && SORTABLE_FIELDS.contains(props.getSort())) {
            aggreagtion.add(Aggregates.sort(
                props.getOrder() == 1
                    ? Sorts.ascending(props.getSort())
                    : Sorts.descending(props.getSort())
            ));
        }

        if (props.getSkip() > 0) aggreagtion.add(Aggregates.skip(props.getSkip()));
        if (props.getLimit() > 0) aggreagtion.add(Aggregates.limit(props.getLimit()));

        AggregateIterable<Document> result;

        try {
            result = DUUIMongoDBStorage
                .Pipelines()
                .aggregate(aggreagtion);
        } catch (IllegalArgumentException exception) {
            return null;
        }

        List<Document> pipelines = StreamSupport.stream(result.spliterator(), false).toList();
        if (pipelines.isEmpty()) return null;


        if (getComponents) {
            for (Document pipeline : pipelines) {
                List<Document> components = DUUIComponentController
                    .getComponentsForPipeline(pipeline.getString("oid"));

                pipeline.append("components", components);
            }
        }

        return new Document("pipelines", pipelines);
    }

    public static String insertOne(Request request, Response response) {
        String authorization = request.headers("Authorization");

        Document user = authenticate(authorization);
        if (isNullOrEmpty(user)) return UserValidator.unauthorized(response);

        Document body = Document.parse(request.body());

        String name = body.getString("name");
        if (name.isEmpty()) return missingField(response, "name");

        List<Document> components = body.getList("components", Document.class);
        if (components.isEmpty()) return missingField(response, "components");

        String template = request.queryParamOrDefault("template", "false").toLowerCase();
        List<String> tags = body.getList("tags", String.class);

        Document pipeline = new Document("name", name)
            .append("description", body.getString("description"))
            .append("created_at", Instant.now().toEpochMilli())
            .append("modified_at", Instant.now().toEpochMilli())
            .append("settings", body.get("settings", Document.class))
            .append("times_used", 0)
            .append("last_used", null)
            .append("status"
                , DUUIStatus.INACTIVE)
            .append("tags", tags)
            .append("user_id", template.equals("true") ? null : user.getObjectId("_id").toString());

        DUUIMongoDBStorage
            .Pipelines()
            .insertOne(pipeline);

        convertObjectIdToString(pipeline);
        String id = pipeline.getString("oid");
        components.forEach(c -> {
                c.put("pipeline_id", id);
                c.remove("oid");
                c.remove("id");
                c.put("index", components.indexOf(c));
            }
        );

        DUUIMongoDBStorage
            .Components()
            .insertMany(components);


        response.status(201);
        return getPipelineById(id).toJson();
    }

    public static String updateOne(Request request, Response response) {
        String id = request.params(":id");
        Document update = Document.parse(request.body());

        DUUIMongoDBStorage
            .Pipelines()
            .findOneAndUpdate(Filters.eq(new ObjectId(id)),
                mergeUpdates(update, ALLOWED_UPDATES));

        List<Document> components = update.getList("components", Document.class);
        if (!isNullOrEmpty(components)) {
            for (Document component : components) {
                DUUIComponentController
                    .setIndex(
                        component.getString("oid"),
                        components.indexOf(component));
            }
        }

        response.status(200);
        return getPipelineById(id).toJson();
    }

    public static String deleteOne(Request request, Response response) {
        String authorization = request.headers("Authorization");

        Document user = authenticate(authorization);
        if (isNullOrEmpty(user)) return UserValidator.unauthorized(response);

        String id = request.params(":id");

        Document pipeline = getPipelineById(id);
        if (pipeline == null) {
            response.status(404);
            return new Document("message", "No Pipeline found").toJson();
        }

//        if (keepAliveProcesses.containsKey(id)) {
////            keepAliveProcesses.get(id).interrupt();
//            keepAliveProcesses.remove(id);
//        }

        DUUIMongoDBStorage
            .getClient()
            .getDatabase("duui")
            .getCollection("pipelines")
            .deleteOne(Filters.eq(new ObjectId(id)));

        DUUIComponentController.deleteMany(id);

        response.status(204);
        return new Document().toJson();
    }


    public static String startService(Request request, Response response) {
        String authorization = request.headers("Authorization");

        Document user = authenticate(authorization);
        if (isNullOrEmpty(user)) return UserValidator.unauthorized(response);

        Document body = Document.parse(request.body());
        String id = body.getString("oid");

        if (isNullOrEmpty(id)) return missingField(response, "id");

        DUUIMongoDBStorage.Pipelines().findOneAndUpdate(
            Filters.eq(new ObjectId(id)),
            Updates.set("status", DUUIStatus.SETUP)
        );

        try {
            Document pipeline = getPipelineById(id);
            if (pipeline == null) return DUUIRequestHandler.notFound(response);

            DUUIService service = new DUUIService(pipeline);
            keepAliveProcesses.put(id, service);
            service.start();
        } catch (Exception e) {
            response.status(500);
            return new Document("message", e.getMessage()).toJson();
        }

        long serviceStartTime = Instant.now().toEpochMilli();
        DUUIMongoDBStorage.Pipelines().findOneAndUpdate(
            Filters.eq(new ObjectId(id)),
            Updates.set("status", DUUIStatus.IDLE)
        );
        DUUIPipelineController.setServiceStartTime(id, serviceStartTime);

        response.status(200);
        return new Document("status", DUUIStatus.IDLE).toJson();
    }

    public static String stopService(Request request, Response response) {
        String authorization = request.headers("Authorization");

        Document user = authenticate(authorization);
        if (isNullOrEmpty(user)) return UserValidator.unauthorized(response);

        Document body = Document.parse(request.body());
        String id = body.getString("oid");

        if (isNullOrEmpty(id)) return missingField(response, "id");
        DUUIService service = keepAliveProcesses.get(id);
        if (service == null) {
            return new Document("message", "No service running").toJson();
        }

        DUUIMongoDBStorage.Pipelines().findOneAndUpdate(
            Filters.eq(new ObjectId(id)),
            Updates.set("status", DUUIStatus.SHUTDOWN)
        );

        try {
            service.cancel();
        } catch (Exception e) {
            response.status(500);
            return new Document("message", e.getMessage()).toJson();
        }

        DUUIMongoDBStorage.Pipelines().findOneAndUpdate(
            Filters.eq(new ObjectId(id)),
            Updates.set("status", DUUIStatus.INACTIVE)
        );

        response.status(200);
        return new Document("status", DUUIStatus.INACTIVE).toJson();
    }


    public static void setServiceStartTime(String id, long serviceStartTime) {
        DUUIMongoDBStorage
            .getClient()
            .getDatabase("duui")
            .getCollection("pipelines")
            .findOneAndUpdate(
                Filters.eq(new ObjectId(id)),
                Updates.set("serviceStartTime", serviceStartTime)
            );
    }


    public static Map<String, DUUIService> getServices() {
        return keepAliveProcesses;
    }

    public static DUUIService getService(String id) {
        return keepAliveProcesses.get(id);
    }

    public static DUUIService getIdleProcess(String pipelineId) {
        return keepAliveProcesses.get(pipelineId);
    }

    public static void removeService(String id) {
        keepAliveProcesses.remove(id);
    }

    public static boolean pipelineIsActive(String id) {
        return keepAliveProcesses.containsKey(id);
    }

    public static boolean deletePipeline(String pipelineID) {
        DeleteResult result = Pipelines()
            .deleteOne(
                Filters.eq("_id", new ObjectId(pipelineID))
            );

        return result.getDeletedCount() > 0;
    }

    public static void interruptIfRunning(String pipelineID) {
        if (keepAliveProcesses.containsKey(pipelineID)) {
            keepAliveProcesses.get(pipelineID).interrupt();
            keepAliveProcesses.remove(pipelineID);
        }
    }
}
